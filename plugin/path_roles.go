package minio

import (
    "context"
    "errors"
    "fmt"
    "strings"
    "time"

    "github.com/hashicorp/vault/sdk/framework"
    "github.com/hashicorp/vault/sdk/logical"
)

var (
    ErrRoleNotFound = errors.New("role not found")
)

const (
    StaticCredentialType = "static"
    StsCredentialType = "sts"
)

// A role stored in the storage backend
type Role struct {

    // PolicyName is the policy to be attached when creating user static credential
    PolicyName string `json:"policy_name"`

    // PolicyDocument is policy in json format used to create sts credential
    PolicyDocument string `json:"policy_document"`

    // Type of credential created
    CredentialType string `json:"credential_type"`

    // UserNamePrefix is what we prepend to the user static access key
    // followed by the Vault request ID
    UserNamePrefix string `json:"user_name_prefix"`

    // MaxStsTTL is the maximum TTL that STS token can exist before it expires for this role
    MaxStsTTL time.Duration `json:"max_sts_ttl"`

    // MaxTTL is the maximum TTL for static credential to exist after which new ones are created
    MaxTTL string `json:"max_ttl"`
    
}

// List the defined roles
func (b *minioBackend) pathRoles() *framework.Path {
    return &framework.Path{
    Pattern: fmt.Sprintf("roles/?"),
    HelpSynopsis: "List configured roles.",

    Operations: map[logical.Operation]framework.OperationHandler{
        logical.ListOperation: &framework.PathOperation{
            Callback: b.pathRolesList,
        },
    },
    }
}

// pathRolesList lists the currently defined roles
func (b *minioBackend) pathRolesList(ctx context.Context, req *logical.Request, _ *framework.FieldData) (*logical.Response, error) {
    b.Logger().Info("Listing all roles stored in vault!")
    roles, err := b.ListRoles(ctx, req.Storage)

    if err != nil {
        b.Logger().Error("failed to list roles!", err)
        return nil, err
    }

    return logical.ListResponse(roles), nil
}

// Define the CRUD functions for the roles path
func (b *minioBackend) pathRolesCRUD() *framework.Path {
    return &framework.Path{
    Pattern: "roles/" + framework.GenericNameRegex("role"),
    HelpSynopsis: "Configure a Minio user role.",
    HelpDescription: "Use this endpoint to set the police for generated user in this role.",

    Fields: map[string]*framework.FieldSchema{
        "role": &framework.FieldSchema{
        Type: framework.TypeString,
        Description: "Role name.",
        },
        "user_name_prefix": &framework.FieldSchema{
        Type: framework.TypeString,
        Description: "Prefix for static user access key generated by this role.",
        },
        "policy_name": &framework.FieldSchema{
        Type: framework.TypeString,
        Description: "Minio policy name to attach static credentials.",
        },
        "policy_document": &framework.FieldSchema{
        Type: framework.TypeString,
        Description: "Minio policy in json format applied to STS credentials.",
        },
        "credential_type": &framework.FieldSchema{
        Type: framework.TypeString,
        Description: "Type of credential created.",
        },
        "max_sts_ttl": &framework.FieldSchema{
        Type: framework.TypeDurationSecond,
        Default: "24h",
        Description: "Maximum TTL applied to sts token keys.",
        },
        "max_ttl": &framework.FieldSchema{
        Type: framework.TypeString,
        Default: "720h",
        Description: "Maximum TTL applied to static credential.",
        },
    },

    ExistenceCheck: b.pathRoleExistsCheck,

    Operations: map[logical.Operation]framework.OperationHandler{
        logical.CreateOperation: &framework.PathOperation{
            Callback: b.pathRoleWrite,
            },
        logical.ReadOperation: &framework.PathOperation{
            Callback: b.pathRoleRead,
            },
        logical.UpdateOperation: &framework.PathOperation{
            Callback: b.pathRoleWrite,
            },
        logical.DeleteOperation: &framework.PathOperation{
            Callback: b.pathRoleDelete,
            },
        },
    }
}

// pathRoleExistsCheck checks to see if a role exists
func (b *minioBackend) pathRoleExistsCheck(ctx context.Context, req *logical.Request, d *framework.FieldData) (bool, error) {
    role := d.Get("role").(string)
    if r, err := b.GetRole(ctx, req.Storage, role); err != nil || r == nil {
        return false, nil
    }

    return true, nil
}

// pathRoleRead reads information on a current role
func (b *minioBackend) pathRoleRead(ctx context.Context, req *logical.Request, d *framework.FieldData) (*logical.Response, error) {
    role := d.Get("role").(string)
    b.Logger().Info("Retrieving role " + role + " details stored in vault!")
    r, err := b.GetRole(ctx, req.Storage, role)

    if err != nil {
        if err == ErrRoleNotFound {
            return logical.ErrorResponse(err.Error()), logical.ErrInvalidRequest
        }
        b.Logger().Error("failed to get role details", err)
        return nil, err
    }
    var role_data map[string]interface{}

    if r.CredentialType == StaticCredentialType {
        role_data = map[string]interface{}{
            "user_name_prefix": r.UserNamePrefix,
            "policy_name": r.PolicyName,
            "max_ttl": r.MaxTTL,
            "credential_type": r.CredentialType,
        }
    } else if r.CredentialType == StsCredentialType {
        role_data = map[string]interface{}{
            "policy_name": r.PolicyName,
            "policy_document": r.PolicyDocument,
            "max_sts_ttl": r.MaxStsTTL.Seconds(),
            "credential_type": r.CredentialType,
        }
    }

    return &logical.Response{
    Data:role_data,
    }, nil
}

// pathRoleWrite creates/updates a role entry
func (b *minioBackend) pathRoleWrite(ctx context.Context, req *logical.Request, d *framework.FieldData) (*logical.Response, error) {
    role := d.Get("role").(string)
    b.Logger().Info("Writing role " + role + " in vault!")
    var r Role

    keys := []string{"user_name_prefix", "policy_name", "credential_type", "policy_document"}

    for _, key := range keys {
        nv := strings.TrimSpace(d.Get(key).(string))

        switch key {
          case "user_name_prefix":
            r.UserNamePrefix = nv
          case "policy_name":
            r.PolicyName = nv
          case "credential_type":
            r.CredentialType = nv
          case "policy_document":
            r.PolicyDocument = nv
        }
    }

    r.MaxTTL = d.Get("max_ttl").(string)
    r.MaxStsTTL = time.Duration(d.Get("max_sts_ttl").(int)) * time.Second
    
    entry, err := logical.StorageEntryJSON("roles/"+role, &r)
    if err != nil {
        b.Logger().Error("failed to create storage entry when updating role!", err)
        return nil, fmt.Errorf("failed to create storage entry: %v", err)
    }

    if err := req.Storage.Put(ctx, entry); err != nil {
        b.Logger().Error("failed to write entry to storage when updating role!", err)
        return nil, fmt.Errorf("failed to write entry to storage: %v", err)
    }

    return nil, nil
}

// pathRoleDelete deletes a role
func (b *minioBackend) pathRoleDelete(ctx context.Context, req *logical.Request, d *framework.FieldData) (*logical.Response, error) {
    b.Logger().Info("Deleting role from in vault!")
    roleName := d.Get("role").(string)
    r, err := b.GetRole(ctx, req.Storage, roleName)
    if err != nil {
        b.Logger().Error("error in getting role", err)
        return nil, err
    }
    b.Logger().Info("Removing all credentials from vault and minio for " + roleName)
    err = b.removeAllUser(ctx, req, r, roleName)
    if err != nil {
        b.Logger().Error("failed to remove all user credentials when deleting role", err)
        return nil, err
    }

    if err = req.Storage.Delete(ctx, "roles/"+roleName); err != nil {
        b.Logger().Error("failed to delete role from storage!", err)
        return nil, fmt.Errorf("failed to delete role from storage: %v", err)
    }
    
    return nil, nil
}

func (b* minioBackend) ListRoles(ctx context.Context, s logical.Storage) ([]string, error) {
    roles, err := s.List(ctx, "roles/")
    if err != nil {
        b.Logger().Error("unable to retrieve list of roles!", err)
        return nil, fmt.Errorf("unable to retrieve list of roles: %v", err)
    }

    return roles, nil
}
func (b* minioBackend) GetRole(ctx context.Context, s logical.Storage, role string) (*Role, error) {
    r, err := s.Get(ctx, "roles/"+role)
    if err != nil { 
        b.Logger().Error("unable to retrieve role", err)
        return nil, fmt.Errorf("unable to retrieve role %v %v", role, err)
    }

    if r == nil {
    return nil, ErrRoleNotFound
    }

    var rv Role
    if err := r.DecodeJSON(&rv); err != nil {
        b.Logger().Error("unable to decode role!", err)
        return nil, fmt.Errorf("unable to decode role %v: %v", role, err)
    }

    return &rv, nil
}