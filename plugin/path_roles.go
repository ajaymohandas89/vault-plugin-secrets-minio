package minio

import (
    "context"
    "fmt"
    "strings"
    "time"

    "github.com/hashicorp/errwrap"
    "github.com/hashicorp/vault/sdk/logical"
    "github.com/hashicorp/vault/sdk/framework"
)


// List the defined roles
func (b *minioBackend) pathRoles() *framework.Path {
    return &framework.Path{
    Pattern: fmt.Sprintf("roles/?"),
    HelpSynopsis: "List configured roles.",

    Operations: map[logical.Operation]framework.OperationHandler{
        logical.ListOperation: &framework.PathOperation{
            Callback: b.pathRolesList,
        },
    },
    }
}

// pathRolesList lists the currently defined roles
func (b *minioBackend) pathRolesList(ctx context.Context, req *logical.Request, _ *framework.FieldData) (*logical.Response, error) {
    roles, err := b.ListRoles(ctx, req.Storage)

    if err != nil {
        return nil, err
    }

    return logical.ListResponse(roles), nil
}

// Define the CRUD functions for the roles path
func (b *minioBackend) pathRolesCRUD() *framework.Path {
    return &framework.Path{
    Pattern: fmt.Sprintf("roles/" + framework.GenericNameRegex("role")),
    HelpSynopsis: "Configure a Minio user role.",
    HelpDescription: "Use this endpoint to set the police for generated user in this role.",

    Fields: map[string]*framework.FieldSchema{
        "role": &framework.FieldSchema{
        Type: framework.TypeString,
        Description: "Role name.",
        },
        "user_name_prefix": &framework.FieldSchema{
        Type: framework.TypeString,
        Description: "Prefix for user access key generated by this role.",
        },
        "policy_name": &framework.FieldSchema{
        Type: framework.TypeString,
        Description: "Minio user policy to apply.",
        },
        "sts_max_ttl": &framework.FieldSchema{
        Type: framework.TypeDurationSecond,
        Default: "900",
        Description: "Maximum TTL to apply to sts token keys.",
        },
    },

    ExistenceCheck: b.pathRoleExistsCheck,

    Operations: map[logical.Operation]framework.OperationHandler{
        logical.CreateOperation: &framework.PathOperation{
            Callback: b.pathRoleWrite,
            },
        logical.ReadOperation: &framework.PathOperation{
            Callback: b.pathRoleRead,
            },
        logical.UpdateOperation: &framework.PathOperation{
            Callback: b.pathRoleWrite,
            },
        logical.DeleteOperation: &framework.PathOperation{
            Callback: b.pathRoleDelete,
            },
        },
    }
}

// pathRoleExistsCheck checks to see if a role exists
func (b *minioBackend) pathRoleExistsCheck(ctx context.Context, req *logical.Request, d *framework.FieldData) (bool, error) {
    role := d.Get("role").(string)
    if r, err := b.GetRole(ctx, req.Storage, role); err != nil || r == nil {
        return false, nil
    }

    return true, nil
}

// pathRoleRead reads information on a current role
func (b *minioBackend) pathRoleRead(ctx context.Context, req *logical.Request, d *framework.FieldData) (*logical.Response, error) {
    role := d.Get("role").(string)

    r, err := b.GetRole(ctx, req.Storage, role)

    if err != nil {
        if err == ErrRoleNotFound {
            return logical.ErrorResponse(err.Error()), logical.ErrInvalidRequest
        }
        return nil, err
    }

    role_data := map[string]interface{}{
    "user_name_prefix": r.UserNamePrefix,
    "policy_name": r.PolicyName,
    "sts_max_ttl": r.StsMaxTTL.Seconds(),
    }

    return &logical.Response{
    Data:role_data,
    }, nil
}

// pathRoleWrite creates/updates a role entry
func (b *minioBackend) pathRoleWrite(ctx context.Context, req *logical.Request, d *framework.FieldData) (*logical.Response, error) {
    role := d.Get("role").(string)

    var r Role
    var keys []string

    keys = []string{"user_name_prefix", "policy_name"}

    for _, key := range keys {
        nv := strings.TrimSpace(d.Get(key).(string))

        switch key {
          case "user_name_prefix":
            r.UserNamePrefix = nv
          case "policy_name":
            r.PolicyName = nv
        }
    }

    // Handle TTL
    r.StsMaxTTL = time.Duration(d.Get("sts_max_ttl").(int)) * time.Second

    entry, err := logical.StorageEntryJSON("roles/"+role, &r)
    if err != nil {
        return nil, errwrap.Wrapf("failed to create storage entry: {{err}}", err)
    }

    if err := req.Storage.Put(ctx, entry); err != nil {
        return nil, errwrap.Wrapf("failed to write entry to storage: {{err}}", err)
    }

    return nil, nil
}

// pathRoleDelete deletes a role
func (b *minioBackend) pathRoleDelete(ctx context.Context, req *logical.Request, d *framework.FieldData) (*logical.Response, error) {
    role := d.Get("role").(string)

    err := b.removeUser(ctx, req, role)

    if err != nil {
        return nil, err
    }

    if err = req.Storage.Delete(ctx, "roles/"+role); err != nil {
        return nil, errwrap.Wrapf("Failed to delete role from storage: {{err}}", err)
    }
    
    return nil, nil
}